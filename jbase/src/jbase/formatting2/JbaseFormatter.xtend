/*
 * generated by Xtext
 */
package jbase.formatting2;

import com.google.inject.Inject
import java.util.List
import jbase.jbase.JbasePackage
import jbase.jbase.XJArrayAccessExpression
import jbase.jbase.XJArrayConstructorCall
import jbase.jbase.XJAssignment
import jbase.jbase.XJBreakStatement
import jbase.jbase.XJConditionalExpression
import jbase.jbase.XJContinueStatement
import jbase.jbase.XJJvmFormalParameter
import jbase.jbase.XJPrefixOperation
import jbase.jbase.XJSwitchStatements
import jbase.jbase.XJVariableDeclaration
import jbase.util.JbaseModelUtil
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.xbase.XBlockExpression
import org.eclipse.xtext.xbase.XCastedExpression
import org.eclipse.xtext.xbase.XDoWhileExpression
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.XForLoopExpression
import org.eclipse.xtext.xbase.XIfExpression
import org.eclipse.xtext.xbase.XMemberFeatureCall
import org.eclipse.xtext.xbase.XPostfixOperation
import org.eclipse.xtext.xbase.XSwitchExpression
import org.eclipse.xtext.xbase.XVariableDeclaration
import org.eclipse.xtext.xbase.formatting2.XbaseFormatter

import static org.eclipse.xtext.xbase.XbasePackage.Literals.*
import static org.eclipse.xtext.xbase.formatting2.XbaseFormatterPreferenceKeys.*

class JbaseFormatter extends XbaseFormatter {
	
	@Inject extension JbaseModelUtil
	
	override void format(Object expr, extension IFormattableDocument document) {
		// you could use dispatch methods, but that will generate many other
		// if cases for inherited dispatch methods that will never be executed during the
		// tests and I prefer to have full control on code coverage.
		if (expr instanceof XJAssignment) {
			_format(expr, document);
		} else if (expr instanceof XJJvmFormalParameter) {
			_format(expr, document);
		} else if (expr instanceof XJPrefixOperation) {
			_format(expr, document);
		} else if (expr instanceof XJConditionalExpression) {
			_format(expr, document);
		} else if (expr instanceof XJSwitchStatements) {
			_format(expr, document);
		} else if (expr instanceof XJVariableDeclaration) {
			_format(expr, document);
		} else if (expr instanceof XCastedExpression) {
			_format(expr, document);
		} else if (expr instanceof XPostfixOperation) {
			_format(expr, document);
		} else if (expr instanceof XJArrayAccessExpression) {
			_format(expr, document);
		} else if (expr instanceof XJArrayConstructorCall) {
			_format(expr, document);
		} else if (expr instanceof XJBreakStatement) {
			_format(expr, document);
		} else if (expr instanceof XJContinueStatement) {
			_format(expr, document);
		} else {
			super.format(expr, document)
		}
	}

	def void _format(XJJvmFormalParameter param, extension IFormattableDocument document) {
		super._format(param, document);
		param.
			regionForFeature(JbasePackage.eINSTANCE.XJJvmFormalParameter_Final).
			append[oneSpace]
	}

	def void _format(XJVariableDeclaration expr, extension IFormattableDocument document) {
		expr.type.append[oneSpace]
		expr.regionForKeyword("=").surround[oneSpace]
		expr.type.format(document)
		expr.right.format(document)
		
		for (XVariableDeclaration additionalVariable : expr.getAdditionalVariables()) {
			format(additionalVariable, document);
			additionalVariable.immediatelyPrecedingKeyword(",").prepend[noSpace].append[oneSpace]
			additionalVariable.regionForKeyword("=").surround[oneSpace]
		}

		formatMandatorySemicolon(expr, document)
	}

	def void _format(XJAssignment expr, extension IFormattableDocument document) {
		super._format(expr, document) 
		formatArrayIndexes(expr.getIndexes(), document)
	}

	def void _format(XJConditionalExpression expr, extension IFormattableDocument document) {
		format(expr.getThen(), document);
		format(expr.getElse(), document);
		format(expr.getIf(), document);

		expr.regionForKeyword("?").surround[oneSpace]
		expr.regionForKeyword(":").surround[oneSpace]
	}

	def void _format(XJArrayConstructorCall expr, extension IFormattableDocument document) {
		expr.
			regionForFeature(JbasePackage.eINSTANCE.XJArrayConstructorCall_Type).
			prepend[oneSpace]
		
		// we must consider the case of a dimension with index expression
		// and without index expression
		for (XExpression index : expr.arrayDimensionIndexAssociations) {
			if (index != null) {
				formatArrayIndex(index, document);
			}
		}
		for (d : expr.dimensions) {
			d.regionForKeyword("[").
				prepend[noSpace].append[noSpace]
			d.immediatelyFollowingKeyword("]").prepend[noSpace]
		}
		
		val arrayLiteral = expr.getArrayLiteral()
		if (arrayLiteral != null) {
			format(arrayLiteral, document);
			arrayLiteral.regionForKeyword("{").prepend[oneSpace]
		}
	}

	/**
	 * This can be removed when https://bugs.eclipse.org/bugs/show_bug.cgi?id=471239 is applied
	 */
	override void _format(XCastedExpression expr, extension IFormattableDocument document) {
		format(expr.getType(), document);
		format(expr.getTarget(), document);
		expr.regionForKeyword("(").surround[noSpace]
		expr.regionForKeyword(")").prepend[noSpace].append[oneSpace]
	}

	def void _format(XJPrefixOperation expr, extension IFormattableDocument document) {
		format(expr.getOperand(), document);
		expr.regionForFeature(XABSTRACT_FEATURE_CALL__FEATURE).append[noSpace]
	}

	def void _format(XJArrayAccessExpression expr, extension IFormattableDocument document) {
		format(expr.getArray(), document);
		formatArrayIndexes(expr.indexes, document)
		formatMandatorySemicolon(expr, document)
	}

	def void _format(XJBreakStatement expr, extension IFormattableDocument document) {
		expr.regionForKeyword("break").surround[noSpace]
		formatMandatorySemicolon(expr, document)
	}

	def void _format(XJContinueStatement expr, extension IFormattableDocument document) {
		expr.regionForKeyword("continue").surround[noSpace]
		formatMandatorySemicolon(expr, document)
	}

	override void _format(XMemberFeatureCall expr, extension IFormattableDocument document) {
		super._format(expr, document)
		formatMandatorySemicolon(expr, document)
	}

	override void _format(XForLoopExpression expr, extension IFormattableDocument format) {
		super._format(expr, format)
		format(expr.declaredParam, format)
	}

	override void _format(XIfExpression expr, extension IFormattableDocument format) {
		expr.^if.surround[noSpace]
		expr.regionForKeyword("if").append[oneSpace]
		if (expr.then instanceof XBlockExpression) {
			expr.then.prepend(bracesInNewLine)
			if (expr.^else != null)
				expr.then.append(bracesInNewLine)
		} else {
			expr.then.prepend[newLine increaseIndentation]
			if (expr.^else != null) {
				expr.then.immediatelyFollowingKeyword(";").append[newLine; decreaseIndentation]
			} else
				expr.then.append[decreaseIndentation]
		}
		if (expr.^else instanceof XBlockExpression) {
			expr.^else.prepend(bracesInNewLine)
		} else if (expr.^else instanceof XIfExpression) {
			expr.^else.prepend[oneSpace]
		} else {
			expr.^else.prepend[newLine increaseIndentation]
			expr.^else.append[decreaseIndentation]
		}
		expr.^if.format(format)
		expr.then.format(format)
		if (expr.^else != null)
			expr.^else.format(format)

//		super._format(expr, format)
		// this is required otherwise there's no space after the if
		// again, probably due to the way we implement XJMemberFeatureCall
		// (see also JbaseHiddenRegionFormattingMerger)
		expr.regionForKeyword("if").append[oneSpace; highPriority]
	}

	override void _format(XDoWhileExpression expr, extension IFormattableDocument format) {
		expr.regionForKeyword("while").append(whitespaceBetweenKeywordAndParenthesisML)
		expr.predicate.prepend[noSpace].append[noSpace]
		if (expr.body instanceof XBlockExpression) {
			expr.body.prepend(bracesInNewLine).append(bracesInNewLine)
		} else {
			expr.body.immediatelyFollowingKeyword(";").append[newLine; decreaseIndentation]
		}
		expr.predicate.format(format)
		expr.body.format(format)
		// the following does not seem to work...
		formatMandatorySemicolon(expr, format)
	}

	override void _format(XSwitchExpression expr, extension IFormattableDocument document) {
		super._format(expr, document)
		expr.regionForKeyword("(").append[noSpace]
		expr.regionForKeyword(")").prepend[noSpace]
	}

	def void _format(XJSwitchStatements expr, extension IFormattableDocument document) {
		formatExpressions(expr.expressions, document, true)
	}

	override createHiddenRegionFormattingMerger() {
		new JbaseHiddenRegionFormattingMerger(this)
	}

	protected def formatExpressions(EList<XExpression> expressions, extension IFormattableDocument document,
			boolean noLineAfterLastExpression) {
		val last = expressions.last
		for (child : expressions) {
			child.format(document)
			val sem = child.immediatelyFollowingKeyword(";")

			if (noLineAfterLastExpression && child == last) {
				sem.prepend[noSpace]
			} else {
				if (sem != null)
					sem.prepend[noSpace].append(blankLinesAroundExpression)
				else
					child.append(blankLinesAroundExpression)
			}
		}
	}

	def private void formatArrayIndexes(List<XExpression> indexes, extension IFormattableDocument document) {
		for (XExpression index : indexes) {
			formatArrayIndex(index, document)
		}
	}
	
	private def formatArrayIndex(XExpression index, extension IFormattableDocument document) {
		index.immediatelyPrecedingKeyword("[").prepend[noSpace; highPriority].append[noSpace]
		format(index, document);
		index.immediatelyFollowingKeyword("]").prepend[noSpace]
	}

	private def formatMandatorySemicolon(XExpression expr, extension IFormattableDocument document) {
		expr.immediatelyFollowingKeyword(";").prepend[noSpace]
	}
}
