/*
 * generated by Xtext
 */
package jbase.formatting2;

import com.google.inject.Inject
import java.util.List
import jbase.jbase.JbasePackage
import jbase.jbase.XJArrayAccessExpression
import jbase.jbase.XJArrayConstructorCall
import jbase.jbase.XJAssignment
import jbase.jbase.XJBreakStatement
import jbase.jbase.XJConditionalExpression
import jbase.jbase.XJContinueStatement
import jbase.jbase.XJJvmFormalParameter
import jbase.jbase.XJPrefixOperation
import jbase.jbase.XJSemicolonStatement
import jbase.jbase.XJSwitchStatements
import jbase.jbase.XJVariableDeclaration
import jbase.util.JbaseModelUtil
import org.eclipse.emf.common.util.EList
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.xbase.XCastedExpression
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.XForLoopExpression
import org.eclipse.xtext.xbase.XPostfixOperation
import org.eclipse.xtext.xbase.XSwitchExpression
import org.eclipse.xtext.xbase.XVariableDeclaration

import static org.eclipse.xtext.xbase.XbasePackage.Literals.*
import static org.eclipse.xtext.xbase.formatting2.XbaseFormatterPreferenceKeys.*
import jbase.jbase.XJTryWithResourcesStatement
import jbase.jbase.XJWithSemicolon
import org.eclipse.xtext.xbase.XConstructorCall

class JbaseFormatter extends XbasePatchedFormatter {

	@Inject extension JbaseModelUtil

	override void format(Object expr, extension IFormattableDocument document) {
		// you could use dispatch methods, but that will generate many other
		// if cases for inherited dispatch methods that will never be executed during the
		// tests and I prefer to have full control on code coverage.
		if (expr instanceof XJAssignment) {
			_format(expr, document);
		} else if (expr instanceof XJJvmFormalParameter) {
			_format(expr, document);
		} else if (expr instanceof XJPrefixOperation) {
			_format(expr, document);
		} else if (expr instanceof XJConditionalExpression) {
			_format(expr, document);
		} else if (expr instanceof XJSwitchStatements) {
			_format(expr, document);
		} else if (expr instanceof XJVariableDeclaration) {
			_format(expr, document);
		} else if (expr instanceof XCastedExpression) {
			_format(expr, document);
		} else if (expr instanceof XPostfixOperation) {
			_format(expr, document);
		} else if (expr instanceof XJArrayAccessExpression) {
			_format(expr, document);
		} else if (expr instanceof XJArrayConstructorCall) {
			_format(expr, document);
		} else if (expr instanceof XJBreakStatement) {
			_format(expr, document);
		} else if (expr instanceof XJContinueStatement) {
			_format(expr, document);
		} else if (expr instanceof XJTryWithResourcesStatement) {
			_format(expr, document);
		} else if (expr instanceof XJSemicolonStatement) {
			_format(expr, document);
		} else {
			super.format(expr, document)
		}
	}

	def void _format(XJJvmFormalParameter param, extension IFormattableDocument document) {
		super._format(param, document);
		param.
			regionFor.feature(JbasePackage.eINSTANCE.XJJvmFormalParameter_Final).
			append[oneSpace]
	}

	def void _format(XJVariableDeclaration expr, extension IFormattableDocument document) {
		expr.type.append[oneSpace]
		expr.regionFor.keyword("=").surround[oneSpace]
		expr.type.format(document)
		expr.right.format(document)
		
		for (XVariableDeclaration additionalVariable : expr.getAdditionalVariables()) {
			format(additionalVariable, document);
			additionalVariable.immediatelyPreceding.keyword(",").prepend[noSpace].append[oneSpace]
			additionalVariable.regionFor.keyword("=").surround[oneSpace]
		}
	}

	def void _format(XJAssignment expr, extension IFormattableDocument document) {
		super._format(expr, document) 
		formatArrayIndexes(expr.getIndexes(), document)
	}

	def void _format(XJConditionalExpression expr, extension IFormattableDocument document) {
		format(expr.getThen(), document);
		format(expr.getElse(), document);
		format(expr.getIf(), document);

		expr.regionFor.keyword("?").surround[oneSpace]
		expr.regionFor.keyword(":").surround[oneSpace]
	}

	def void _format(XJArrayConstructorCall expr, extension IFormattableDocument document) {
		expr.
			regionFor.feature(JbasePackage.eINSTANCE.XJArrayConstructorCall_Type).
			prepend[oneSpace]
		
		// we must consider the case of a dimension with index expression
		// and without index expression
		for (XExpression index : expr.arrayDimensionIndexAssociations) {
			if (index !== null) {
				formatArrayIndex(index, document);
			}
		}
		for (d : expr.dimensions) {
			d.regionFor.keyword("[").
				prepend[noSpace].append[noSpace]
			d.immediatelyFollowing.keyword("]").prepend[noSpace]
		}
		
		val arrayLiteral = expr.getArrayLiteral()
		if (arrayLiteral !== null) {
			format(arrayLiteral, document);
			arrayLiteral.regionFor.keyword("{").prepend[oneSpace]
		}
	}

	override void _format(XCastedExpression expr, extension IFormattableDocument document) {
		format(expr.getType(), document);
		format(expr.getTarget(), document);
		expr.handleOpenCloseParenthesis("(", ")", document)
		expr.regionFor.keyword(")").append[oneSpace]
	}

	def void _format(XJPrefixOperation expr, extension IFormattableDocument document) {
		format(expr.getOperand(), document);
		expr.regionFor.feature(XABSTRACT_FEATURE_CALL__FEATURE).append[noSpace]
	}

	def void _format(XJArrayAccessExpression expr, extension IFormattableDocument document) {
		format(expr.getArray(), document);
		formatArrayIndexes(expr.indexes, document)
	}

	def void _format(XJBreakStatement expr, extension IFormattableDocument document) {
		expr.regionFor.keyword("break").surround[noSpace]
	}

	def void _format(XJContinueStatement expr, extension IFormattableDocument document) {
		expr.regionFor.keyword("continue").surround[noSpace]
	}

	override void _format(XForLoopExpression expr, extension IFormattableDocument format) {
		super._format(expr, format)
		format(expr.declaredParam, format)
	}

	override void _format(XSwitchExpression expr, extension IFormattableDocument document) {
		super._format(expr, document)
		expr.regionFor.keyword("(").append[noSpace]
		expr.regionFor.keyword(")").prepend[noSpace]
	}

	def void _format(XJTryWithResourcesStatement expr, extension IFormattableDocument document) {
		expr.regionFor.keyword("try").append[oneSpace]
		expr.regionFor.keyword("(").append[noSpace]
		expr.regionFor.keyword(")").prepend[noSpace]
		for (r : expr.resourceDeclarations) {
			r.format(document)
			r.formatSemicolon(document)
		}
		super._format(expr, document)
	}

	def void _format(XJSwitchStatements expr, extension IFormattableDocument document) {
		formatExpressions(expr.expressions, document, true)
	}

	def void _format(XJSemicolonStatement e, extension IFormattableDocument document) {
		if (e.expression !== null)
			format(e.expression, document)
		formatSemicolon(e, document)
	}

	override void _format(XConstructorCall expr, extension IFormattableDocument document) {
		// case for diamond
		if (expr.typeArguments.empty) {
			expr.handleOpenCloseParenthesis("<", ">", document)
		}
		super._format(expr, document)
	}

	def void formatSemicolon(XJWithSemicolon e, extension IFormattableDocument document) {
		e.regionFor.keyword(";").prepend[noSpace]
	}

	protected def formatExpressions(EList<XExpression> expressions, extension IFormattableDocument document,
			boolean noLineAfterLastExpression) {
		val last = expressions.last
		for (child : expressions) {
			child.format(document)

			if (!noLineAfterLastExpression || child != last) {
				child.append(blankLinesAroundExpression)
			}
		}
	}

	def private void formatArrayIndexes(List<XExpression> indexes, extension IFormattableDocument document) {
		for (XExpression index : indexes) {
			formatArrayIndex(index, document)
		}
	}

	private def formatArrayIndex(XExpression index, extension IFormattableDocument document) {
		index.immediatelyPreceding.keyword("[").prepend[noSpace; highPriority].append[noSpace]
		format(index, document);
		index.immediatelyFollowing.keyword("]").prepend[noSpace]
	}

	def private handleOpenCloseParenthesis(XExpression expr, String open, String close, extension IFormattableDocument document) {
		expr.regionFor.keyword(open).surround[noSpace]
		expr.regionFor.keyword(close).prepend[noSpace]
	}
}
