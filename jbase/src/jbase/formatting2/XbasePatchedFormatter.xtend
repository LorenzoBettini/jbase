/*
 * generated by Xtext
 */
package jbase.formatting2;

import com.google.inject.Inject
import jbase.services.JbaseGrammarAccess
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.formatting2.IFormattableDocument
import org.eclipse.xtext.formatting2.regionaccess.ISemanticRegion
import org.eclipse.xtext.xbase.XFeatureCall
import org.eclipse.xtext.xbase.XMemberFeatureCall
import org.eclipse.xtext.xbase.annotations.formatting2.XbaseWithAnnotationsFormatter
import org.eclipse.xtext.xbase.formatting2.IndentOnceAutowrapFormatter
import org.eclipse.xtext.xbase.formatting2.SeparatorRegions

import static org.eclipse.xtext.xbase.XbasePackage.Literals.*

/**
 * To avoid breaking changes introduced in the XbaseFormatter that rely NOT on keywords but
 * on grammar access, e.g., https://github.com/eclipse/xtext-extras/commit/b5a52c9ec20e41920cf0ec950e4f416dbf688109
 */
class XbasePatchedFormatter extends XbaseWithAnnotationsFormatter {

	@Inject extension JbaseGrammarAccess grammar

	override protected _format(XFeatureCall expr, extension IFormattableDocument format) {
		formatFeatureCallTypeParameters(expr, format)
		if (expr.explicitOperationCall) {
			// The Jbase grammar changed the rule for feature call, so we must change the
			// names of the methods for accessing grammar elements
			val open = expr.regionFor.keyword(grammar.XFeatureCallAccess.explicitOperationCallLeftParenthesisKeyword_2_0_0).prepend[noSpace]
			val close = expr.regionFor.keyword(grammar.XFeatureCallAccess.rightParenthesisKeyword_2_2)
			formatFeatureCallParams(expr.featureCallArguments, open, close, format)
		} else
			for (arg : expr.featureCallArguments)
				format(arg, format)
	}

	override protected _format(XMemberFeatureCall expr, extension IFormattableDocument format) {
		var EObject top = expr
		var calls = new SeparatorRegions<XMemberFeatureCall, ISemanticRegion>(expr.regionForEObject)
		while (top instanceof XMemberFeatureCall) {
			val op = switch it: top { case nullSafe: "?." case explicitStatic: "::" default: "." }
			val separator = top.regionFor.keyword(op)
			calls.prependWithLeadingSeparator(top, separator)
			top = top.memberCallTarget
		}
		top.format
		val indentOnce = new IndentOnceAutowrapFormatter(expr.nextHiddenRegion)
		for (entry : calls) {
			val call = entry.object
			val operator = entry.leadingSeparator.separator
			formatFeatureCallTypeParameters(call, format)
			val feature = call.regionFor.feature(XABSTRACT_FEATURE_CALL__FEATURE)
			if (feature !== null) {
				val autowrapLength = Math.min(entry.region.length, feature.length * 2)
				operator.prepend[noSpace].append[noSpace; autowrap(autowrapLength) onAutowrap = indentOnce]
				if (call.explicitOperationCall) {
					// The Jbase grammar changed the rule for feature call, so we must change the
					// names of the methods for accessing grammar elements
					val open = call.regionFor.keyword(grammar.XMemberFeatureCallAccess.explicitOperationCallLeftParenthesisKeyword_1_2_2_0_0).prepend[noSpace]
					val close = call.regionFor.keyword(grammar.XMemberFeatureCallAccess.rightParenthesisKeyword_1_2_2_2)
					formatFeatureCallParams(call.memberCallArguments, open, close, format)
				} else if (!call.memberCallArguments.empty) {
					formatBuilderWithLeadingGap(call.memberCallArguments.builder, format)
				}
			}
		}
	}

}
