/*
 * generated by Xtext
 */
package jbase.validation

import com.google.inject.Inject
import java.util.List
import jbase.jbase.XJAdditionalXVariableDeclaration
import jbase.jbase.XJArrayConstructorCall
import jbase.jbase.XJBranchingStatement
import jbase.jbase.XJBreakStatement
import jbase.jbase.XJContinueStatement
import jbase.jbase.XJJvmFormalParameter
import jbase.jbase.JbasePackage
import jbase.scoping.featurecalls.JbaseOperatorMapping
import jbase.util.JbaseModelUtil
import jbase.util.JbaseNodeModelUtil
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EStructuralFeature
import org.eclipse.xtext.common.types.JvmFormalParameter
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.util.Wrapper
import org.eclipse.xtext.validation.Check
import org.eclipse.xtext.xbase.XAbstractFeatureCall
import org.eclipse.xtext.xbase.XAbstractWhileExpression
import org.eclipse.xtext.xbase.XAssignment
import org.eclipse.xtext.xbase.XBasicForLoopExpression
import org.eclipse.xtext.xbase.XDoWhileExpression
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.XFeatureCall
import org.eclipse.xtext.xbase.XMemberFeatureCall
import org.eclipse.xtext.xbase.XReturnExpression
import org.eclipse.xtext.xbase.XSwitchExpression
import org.eclipse.xtext.xbase.XVariableDeclaration
import org.eclipse.xtext.xbase.XbasePackage
import org.eclipse.xtext.xtype.XImportDeclaration

import static jbase.validation.JbaseIssueCodes.*
import org.eclipse.xtext.xbase.XConstructorCall

/**
 * @author Lorenzo Bettini
 */
class JbaseValidator extends AbstractJbaseValidator {

	static val xbasePackage = XbasePackage.eINSTANCE;
	static val jbasePackage = JbasePackage.eINSTANCE;

	val semicolonStatements = #{
		XJBranchingStatement,
		XVariableDeclaration,
		XDoWhileExpression,
		XReturnExpression,
		XAssignment,
		XAbstractFeatureCall
	}

	val featuresForRequiredSemicolon = #{
		xbasePackage.XBlockExpression_Expressions,
		xbasePackage.XIfExpression_Then,
		xbasePackage.XIfExpression_Else,
		xbasePackage.XCasePart_Then,
		xbasePackage.XAbstractWhileExpression_Body
	}

	@Inject extension JbaseNodeModelUtil
	@Inject extension JbaseModelUtil

	override protected checkAssignment(XExpression expression, EStructuralFeature feature, boolean simpleAssignment) {
		if (expression instanceof XAbstractFeatureCall) {
			val assignmentFeature = expression.feature
			if (assignmentFeature instanceof JvmFormalParameter) {
				// all parameters are considered NOT final by default
				val originalParam = assignmentFeature.originalParam
				if (originalParam == null || !originalParam.isFinal()) {
					return;
				}
			}
		}

		super.checkAssignment(expression, feature, simpleAssignment)
	}

	/**
	 * In case of an additional variable declaration we must use the container of
	 * the containing variable declaration, otherwise additional variables will always be
	 * detected as unused
	 */
	override protected isLocallyUsed(EObject target, EObject containerToFindUsage) {
		if (target instanceof XJAdditionalXVariableDeclaration) {
			return super.isLocallyUsed(target, containerToFindUsage.eContainer)
		}
		return super.isLocallyUsed(target, containerToFindUsage)
	}

	@Check
	def void checkContinue(XJContinueStatement st) {
		checkBranchingStatementInternal(
			st,
			"a loop",
			XAbstractWhileExpression,
			XBasicForLoopExpression
		)
	}

	@Check
	def void checkBreak(XJBreakStatement st) {
		checkBranchingStatementInternal(
			st,
			"a loop or a switch",
			XAbstractWhileExpression,
			XBasicForLoopExpression,
			XSwitchExpression
		)
	}

	def private checkBranchingStatementInternal(XJBranchingStatement st, String errorDetails,
		Class<? extends EObject>... validContainers) {
		val container = Wrapper.wrap(st.eContainer)
		while (container.get != null) {
			if (validContainers.exists[c|c.isInstance(container.get)]) {
				return;
			}
			container.set(container.get.eContainer)
		}
		error(
			st.instruction + " cannot be used outside of " + errorDetails,
			st,
			null,
			INVALID_BRANCHING_STATEMENT
		)
	}

	@Check
	def checkMissingSemicolon(XExpression e) {
		if (e.hasToBeCheckedForMissingSemicolon) {
			checkMissingSemicolonInternal(e)
		}
	}

	@Check
	def checkMissingSemicolon(XImportDeclaration e) {
		checkMissingSemicolonInternal(e)
	}

	def private checkMissingSemicolonInternal(EObject e) {
		if (!e.hasSemicolon) {
			error(
				'Syntax error, insert ";" to complete Statement',
				e,
				null,
				MISSING_SEMICOLON
			)
		}
	}

	def private hasToBeCheckedForMissingSemicolon(XExpression e) {
		val expClass = e.class
		val containingFeature = e.eContainingFeature
		semicolonStatements.exists [ c |
			c.isAssignableFrom(expClass) && featuresForRequiredSemicolon.exists[f|f == containingFeature]
		]
	}

	@Check
	def checkMissingParentheses(XFeatureCall call) {
		checkMissingParenthesesInternal(call, call.isExplicitOperationCall)
	}

	@Check
	def checkMissingParentheses(XMemberFeatureCall call) {
		checkMissingParenthesesInternal(call, call.isExplicitOperationCall)
	}

	@Check
	def checkMissingParentheses(XConstructorCall call) {
		if (!call.explicitConstructorCall) {
			error(
				'Syntax error, insert "()" to complete Expression',
				call,
				xbasePackage.XConstructorCall_Constructor,
				MISSING_PARENTHESES
			)
		}
	}

	@Check
	def checkArrayConstructor(XJArrayConstructorCall cons) {
		val arrayLiteral = cons.arrayLiteral
		val dimensionExpressions = cons.indexes

		if (dimensionExpressions.empty && arrayLiteral == null) {
			error(
				"Constructor must provide either dimension expressions or an array initializer",
				cons,
				null,
				ARRAY_CONSTRUCTOR_EITHER_DIMENSION_EXPRESSION_OR_INITIALIZER
			)
		} else if (!dimensionExpressions.empty && arrayLiteral != null) {
			error(
				"Cannot define dimension expressions when an array initializer is provided",
				cons,
				null,
				ARRAY_CONSTRUCTOR_BOTH_DIMENSION_EXPRESSION_AND_INITIALIZER
			)
		} else {
			val dimensionsAndIndexes = cons.arrayDimensionIndexAssociations
			var foundEmptyDimension = false
			for (d : dimensionsAndIndexes) {
				if (d == null) {
					foundEmptyDimension = true
				} else if (foundEmptyDimension) {
					error(
						"Cannot specify an array dimension after an empty dimension",
						d,
						null,
						ARRAY_CONSTRUCTOR_DIMENSION_EXPRESSION_AFTER_EMPTY_DIMENSION
					)
					return
				}
			}
		}
	}

	def private checkMissingParenthesesInternal(XAbstractFeatureCall call, boolean explicitOpCall) {
		// length for arrays is OK without parentheses
		if (call.feature instanceof JvmOperation && !explicitOpCall &&
			call.feature.simpleName != JbaseOperatorMapping.ARRAY_LENGTH) {
			error(
				'Syntax error, insert "()" to complete method call',
				call,
				xbasePackage.XAbstractFeatureCall_Feature,
				MISSING_PARENTHESES
			)
		}
	}

	@Check
	def void checkVarArgComesLast(XJJvmFormalParameter param) {
		if (param.isVarArgs()) {
			val params = param.eContainer().eGet(param.eContainingFeature()) as List<XJJvmFormalParameter>
			if (param != params.last) {
				error(
					"A vararg must be the last parameter.",
					param,
					jbasePackage.XJJvmFormalParameter_VarArgs,
					JbaseIssueCodes.INVALID_USE_OF_VAR_ARGS
				);
			}
		}
	}
}
